<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shill or No Shill - Host Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root { --vh: 1vh; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0c1020 url('assets/images/backgrounds/game-gradient.svg') center/cover fixed no-repeat;
            color: white;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            height: calc(var(--vh, 1vh) * 100 - 36px);
            gap: 10px;
            padding: 10px;
        }

        .container > * { min-height: 0; }

        /* Left Column - Monetary Values */
        .values-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #ffd700;
            overflow-y: auto;
        }

        .values-title {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .values-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .value-item {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #1e3c72;
            padding: 8px 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            border: 2px solid #ffd700;
        }

        .value-item.eliminated {
            background: linear-gradient(45deg, #666, #999);
            color: #ccc;
            text-decoration: line-through;
            opacity: 0.6;
        }

        .value-item.highlight {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        /* Inline icons for value type and attachments */
        .value-item .value-icons {
            margin-left: 6px;
            font-size: 13px;
            display: inline-block;
            vertical-align: baseline;
        }

        /* Center Column - Cases and Controls */
        .game-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #ffd700;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            overflow: auto;
        }

        .game-title {
            text-align: center;
            margin-bottom: 16px;
            font-family: 'Segoe UI', 'Trebuchet MS', 'Georgia', serif;
            font-weight: 800;
            letter-spacing: 1px;
            line-height: 90px; /* vertically center text in fixed height */
            font-size: 48px; /* balanced to fit within 500px width */
            /* Gold gradient text */
            background: linear-gradient(180deg, #FFD700 0%, #FFC107 35%, #FFB300 55%, rgba(255,255,255,0.6) 80%, #FFD700 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6);
            padding: 0;
            white-space: nowrap; /* keep title on a single line */
            width: 500px; /* requested fixed width */
            height: 90px; /* requested fixed height */
            margin-left: auto; /* center horizontally */
            margin-right: auto; /* center horizontally */
            position: relative; /* allow sparkles to overlay within bounds */
        }

        .game-title img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.7));
        }

        /* Sparkle effect for the title */
        .game-title .sparkle {
            position: absolute;
            pointer-events: none;
            width: var(--s, 12px);
            height: var(--s, 12px);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.6) rotate(var(--rot, 0deg));
            border-radius: 50%;
            background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.95) 0%, rgba(255,215,0,0.85) 35%, rgba(255,180,0,0.6) 55%, rgba(255,215,0,0.0) 70%);
            filter: drop-shadow(0 0 6px rgba(255,215,0,0.85));
            opacity: 0;
            animation: sparklePop var(--dur, 1200ms) ease-out forwards;
        }
        .game-title .sparkle::before,
        .game-title .sparkle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2px;
            height: calc(var(--s, 12px) * 1.8);
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg));
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0.95), rgba(255,255,255,0));
            border-radius: 2px;
            opacity: 0.9;
        }
        .game-title .sparkle::after {
            transform: translate(-50%, -50%) rotate(calc(var(--rot, 0deg) + 90deg));
        }
        @keyframes sparklePop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(var(--rot, 0deg)); }
            35% { opacity: 1; transform: translate(-50%, -50%) scale(1.15) rotate(var(--rot, 0deg)); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.2) rotate(var(--rot, 0deg)); }
        }

        .cases-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            flex: 1;
            margin-bottom: 20px;
        }

        .case {
            background: rgba(20,25,53,0.6);
            background-image: url('assets/images/cases/case-body.svg');
            background-repeat: no-repeat;
            background-position: center;
            background-size: 95% auto;
            color: #ffffff;
            border: 2px solid #4FD1FF;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 90px;
            text-shadow: 0 2px 6px rgba(0,0,0,0.6);
        }

        .case:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
        }

        .case.opened {
            background: linear-gradient(45deg, #333, #555);
            background-image: none;
            color: #ffd700;
            animation: reveal 0.5s ease;
        }

        .case.selected {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: white;
            transform: scale(0.95);
        }

        @keyframes reveal {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .game-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .control-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .new-game-btn {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: white;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .new-game-btn:hover {
            background: linear-gradient(45deg, #45a049, #5cb860);
            transform: translateY(-2px);
        }

        .settings-btn {
            background: linear-gradient(45deg, #9C27B0, #E91E63);
            color: white;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
            opacity: 0;
        }

        .settings-btn:hover::before {
            animation: shine 0.6s ease-out;
            opacity: 1;
        }

        .settings-btn:hover {
            background: linear-gradient(45deg, #7B1FA2, #C2185B);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(156, 39, 176, 0.4);
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        /* Small icon styling */
        .icon {
            width: 20px;
            height: 20px;
            display: inline-block;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
        }

        /* Adjustable background overlay for tuning intensity/color */
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background: var(--bg-tint, #000000);
            opacity: var(--bg-overlay-opacity, 0.20);
            pointer-events: none;
        }

        /* Case number styling */
        .case-number {
            font-family: var(--ui-font, 'Montserrat'), 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 24px;
            letter-spacing: 0.5px;
            color: #ffffff;
            text-shadow: 0 2px 8px rgba(0,0,0,0.7), 0 0 8px rgba(79,209,255,0.6);
            position: relative;
            z-index: 1;
        }

        /* Button hover pulse */
        .control-btn {
            transition: transform 0.15s ease, box-shadow 0.2s ease;
        }
        .control-btn:hover {
            transform: scale(1.03);
            box-shadow: 0 8px 20px rgba(0,0,0,0.35);
        }
        .control-btn:active {
            transform: scale(0.98);
        }

        /* Case open glow animation */
        @keyframes caseGlow {
            0% { box-shadow: 0 0 0 rgba(255,215,0,0.0); }
            30% { box-shadow: 0 0 25px rgba(255,215,0,0.9); }
            100% { box-shadow: 0 0 10px rgba(255,215,0,0.5); }
        }

        .game-status {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .status-text {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
        }

        /* Right Column - Controller and History */
        .controller-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #ffd700;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            overflow: auto;
        }

        /* Top-aligned controller actions under HOST CONTROLLER title */
        .controller-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-top: 8px; /* slight space under title */
            padding-top: 0;
            padding-bottom: 10px; /* requested padding beneath buttons */
            border-top: none;
        }
        .controller-actions .control-btn {
            width: 200px;
            height: 20px;
            padding: 0 8px;
            font-size: 12px;
            line-height: 20px;
        }
        .controller-actions #newGameBtn {
            margin-left: 20px; /* 20px space before New Game button */
        }
        .controller-actions .control-btn .icon {
            width: 14px;
            height: 14px;
        }

        .controller-title {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .offer-section {
            margin-bottom: 20px;
        }

        .max-prize-section {
            margin-bottom: 20px;
        }

        .max-prize-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ffd700;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.1);
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .set-max-prize-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #9C27B0, #E91E63);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .offer-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ffd700;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.1);
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .offer-input::placeholder {
            color: rgba(255, 215, 0, 0.7);
        }

        .set-offer-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .suggested-offer {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid #2196F3;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            color: #2196F3;
            margin-top: 10px;
        }

        .last-value {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .last-value-text {
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
        }

        .history-section {
            flex: 1;
        }

        .history-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
            text-align: center;
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 5px;
            padding: 8px;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .history-offer {
            color: #ffd700;
            font-weight: bold;
        }

        .history-decision {
            color: #4CAF50;
            font-weight: bold;
        }

        .history-decision.reject {
            color: #f44336;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                height: calc(var(--vh, 1vh) * 100 - 36px);
                padding: 5px;
            }

            .values-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .cases-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .game-controls {
                flex-direction: column;
                gap: 15px;
            }

            .control-btn {
                padding: 15px;
                font-size: 16px;
            }
        }

        @media (max-width: 768px) {
            .game-controls {
                flex-direction: column;
                gap: 10px;
            }

            .control-btn {
                padding: 12px;
                font-size: 14px;
            }

            .settings-btn span {
                font-size: 14px;
            }

            .cases-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .values-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
    <!-- Load Montserrat font and apply globally -->
    <link rel="stylesheet" href="assets/css/fonts.css">
    <!-- Window Titlebar Styles -->
    <style>
        .titlebar {
            position: fixed;
            top: 0; left: 0; right: 0;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px 0 12px;
            background: rgba(0,0,0,0.6);
            border-bottom: 1px solid rgba(255,255,255,0.12);
            backdrop-filter: blur(8px);
            -webkit-app-region: drag; /* draggable area when frameless */
            z-index: 10000;
        }
        .titlebar .app-title {
            color: #e6e6e6;
            font-size: 0.95rem;
            letter-spacing: 0.6px;
            text-shadow: 0 2px 6px rgba(0,0,0,0.6);
        }
        .titlebar .window-buttons {
            display: flex;
            gap: 6px;
            -webkit-app-region: no-drag; /* allow clicks */
        }
        .titlebar .btn {
            width: 36px; height: 24px;
            display: grid; place-items: center;
            border-radius: 6px;
            color: #fff;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            cursor: pointer;
            font-weight: 600;
            line-height: 1;
        }
        .titlebar .btn:hover { background: rgba(255,255,255,0.12); }
        .titlebar .btn:active { transform: translateY(1px); }
        .titlebar .btn-close:hover { background: #ff4d4f; border-color: #ff4d4f; }
        .titlebar-spacer { height: 36px; }
    </style>
</head>
<body>
    <div class="titlebar">
        <div class="app-title">Shill Or No Shill â€” Game</div>
        <div class="window-buttons">
            <button id="btn-min" class="btn" title="Minimize">â€”</button>
            <button id="btn-max" class="btn" title="Maximize/Restore">â–¢</button>
            <button id="btn-close" class="btn btn-close" title="Close">âœ•</button>
        </div>
    </div>
    <div class="titlebar-spacer"></div>
    <script>
    (function(){
        const wc = window.windowControls;
        const bind = (id, fn) => { const el = document.getElementById(id); if (el) el.addEventListener('click', fn); };
        bind('btn-min', () => wc?.minimize?.());
        bind('btn-max', () => wc?.maximizeOrRestore?.());
        bind('btn-close', () => wc?.close?.());
    })();
    </script>
    <script>
    // Sync CSS --vh with actual viewport height to avoid OS UI overlaps
    (function(){
        function setVH(){
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
            var vh = h * 0.01;
            document.documentElement.style.setProperty('--vh', vh + 'px');
        }
        setVH();
        window.addEventListener('resize', setVH);
        window.addEventListener('orientationchange', setVH);
    })();
    </script>
    <div class="container">
        <!-- Left Column - Monetary Values -->
        <div class="values-panel">
            <div class="values-title">REMAINING VALUES</div>
            <div class="values-grid" id="valuesGrid">
                <!-- Values will be populated by JavaScript -->
            </div>
        </div>

        <!-- Center Column - Cases and Game Controls -->
        <div class="game-panel">
            <div class="game-title">SHILL OR NO SHILL</div>

            <div class="cases-grid" id="casesGrid">
                <!-- Cases will be populated by JavaScript -->
            </div>

            <div class="game-controls">
                <button id="newGameBtn" class="control-btn new-game-btn" onclick="startNewGame()">
                    <img class="icon" src="assets/images/icons/start.svg" alt="Start">
                    NEW GAME
                </button>
                <button id="settingsBtn" class="control-btn settings-btn" onclick="openGameMasterSettings()" title="Game Master Settings">
                    <img class="icon" src="assets/images/icons/settings.svg" alt="Settings">
                    SETTINGS
                </button>
            </div>

            <div class="game-status">
                <div class="status-text" id="gameStatus">Select your case to begin!</div>
            </div>
        </div>

        <!-- Right Column - Controller and History -->
        <div class="controller-panel">
            <div class="controller-title"><img class="icon" src="assets/images/icons/banker.svg" alt="Host"> HOST CONTROLLER</div>

            <!-- Max prize input removed: max winnings amount is configured only in game-master-settings.html -->

            <div class="offer-section">
                <input type="text" class="offer-input" id="manualOffer" placeholder="Enter Banker's Offer ($ or text)">
                <button id="setOfferBtn" class="set-offer-btn" onclick="setManualOffer()">
                    <img class="icon" src="assets/images/icons/offer.svg" alt="Offer"> SET OFFER
                </button>
                <!-- Manual Banker offers only - no suggestions needed -->
            </div>
            <!-- Decision buttons slot: shown only when relevant -->
            <div id="decisionButtonsSlot" class="decision-buttons-slot" style="display:none; padding:20px 0 40px 0;"></div>

            <div class="last-value">
                <div class="last-value-text" id="lastValue">Last Opened: None</div>
            </div>

            <div class="history-section">
                <div class="history-title">PROPOSITION HISTORY</div>
                <div class="history-list" id="historyList">
                    <!-- History items will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            cases: [],
            values: [],
            remainingValues: [],
            playerCase: null,
            currentRound: 1,
            casesToOpen: 6,
            casesOpened: 0,
            gameActive: false,
            offerHistory: [],
            offerMadeThisRound: false,
            finalRound: false, // Track final round state
            originalPlayerCase: null // Store original case for swap logic
        };

        // Custom max prize amount (can be set by game master)
        let customMaxPrize = null;

        // Standard Deal or No Deal values (base values before scaling)
        const BASE_STANDARD_VALUES = [
            0.01, 1, 5, 10, 25, 50, 75, 100, 200, 300, 400, 500, 750,
            1000, 5000, 10000, 25000, 50000, 75000, 100000, 200000, 300000, 400000, 500000, 750000, 1000000
        ];

        // Gold sparkle effect for the title
        function initTitleSparkles() {
            const el = document.querySelector('.game-title');
            if (!el) return;
            const spawnSparkle = () => {
                const s = document.createElement('div');
                s.className = 'sparkle';
                const size = Math.round(Math.random() * 10 + 8); // 8-18px
                const dur = Math.round(Math.random() * 800 + 900); // 900-1700ms
                const rot = Math.floor(Math.random() * 360);
                const leftPct = Math.random() * 100; // between 0%-100%
                const topJitter = (Math.random() * 26) - 13; // -13% to +13% around middle line
                s.style.setProperty('--s', `${size}px`);
                s.style.setProperty('--dur', `${dur}ms`);
                s.style.setProperty('--rot', `${rot}deg`);
                s.style.left = `${leftPct}%`;
                s.style.top = `${50 + topJitter}%`;
                el.appendChild(s);
                s.addEventListener('animationend', () => s.remove());
                setTimeout(() => s.remove(), dur + 500);
            };
            // Periodic sparkles
            const timer = setInterval(() => {
                const count = Math.random() < 0.6 ? 1 : 2;
                for (let i = 0; i < count; i++) spawnSparkle();
            }, 1200);
            // Boost on hover
            el.addEventListener('mouseenter', () => {
                for (let i = 0; i < 4; i++) setTimeout(spawnSparkle, i * 120);
            });
            // Clean up on unload
            window.addEventListener('beforeunload', () => clearInterval(timer));
        }

        // Layout enhancements: move directions beneath title, and controls to controller bottom-right
        function setupUILayoutEnhancements() {
            try {
                const gamePanel = document.querySelector('.game-panel');
                const titleEl = gamePanel?.querySelector('.game-title');
                const statusEl = gamePanel?.querySelector('.game-status');
                if (gamePanel && titleEl && statusEl) {
                    // Place status directly after title
                    if (statusEl.previousElementSibling !== titleEl) {
                        gamePanel.insertBefore(statusEl, titleEl.nextSibling);
                    }
                    statusEl.style.margin = '-12px auto 16px auto';
                    statusEl.style.maxWidth = '800px';
                }

                const controller = document.querySelector('.controller-panel');
                if (controller) {
                    let actions = controller.querySelector('.controller-actions');
                    const controllerTitle = controller.querySelector('.controller-title');
                    if (!actions) {
                        actions = document.createElement('div');
                        actions.className = 'controller-actions';
                        if (controllerTitle) {
                            controller.insertBefore(actions, controllerTitle.nextSibling);
                        } else {
                            controller.appendChild(actions);
                        }
                    } else if (controllerTitle && actions.previousElementSibling !== controllerTitle) {
                        controller.insertBefore(actions, controllerTitle.nextSibling);
                    }

                    const newGameBtn = document.getElementById('newGameBtn');
                    const settingsBtn = document.getElementById('settingsBtn');
                    const controlsContainer = document.querySelector('.game-controls');
                    if (controlsContainer) {
                        controlsContainer.style.display = 'none';
                    }
                    [newGameBtn, settingsBtn].forEach(btn => {
                        if (btn && btn.parentElement !== actions) {
                            actions.appendChild(btn);
                            btn.style.minWidth = '140px';
                            btn.style.padding = '12px 16px';
                        }
                    });
                }
            } catch (e) {
                console.warn('setupUILayoutEnhancements encountered an issue:', e);
            }
        }

        // Game Master Settings (loaded from localStorage)
        let gameMasterSettings = null;

        // Load Game Master Settings from localStorage
        function loadGameMasterSettings() {
            const savedSettings = localStorage.getItem('shillOrNoShillSettings');
            if (savedSettings) {
                try {
                    gameMasterSettings = JSON.parse(savedSettings);
                    console.log('Loaded Game Master Settings:', gameMasterSettings);
                    return true;
                } catch (e) {
                    console.error('Error loading Game Master Settings:', e);
                    gameMasterSettings = null;
                    return false;
                }
            }
            console.log('No Game Master Settings found, using defaults');
            gameMasterSettings = null;
            return false;
        }



        // Apply Game Master Settings to game
        function applyGameMasterSettings() {
            if (!gameMasterSettings) return;

            // Apply max prize amount (preferred over legacy prizeScaleMultiplier)
            if (gameMasterSettings.maxPrizeAmount && gameMasterSettings.maxPrizeAmount > 0) {
                customMaxPrize = gameMasterSettings.maxPrizeAmount;
                console.log(`Applied max prize amount from settings: ${customMaxPrize}`);
            }

            // Apply number of cases (if different from default 25)
            if (gameMasterSettings.numberOfCases && gameMasterSettings.numberOfCases !== 25) {
                const numCases = Math.max(10, Math.min(50, gameMasterSettings.numberOfCases));
                // Recreate cases array with new count
                gameState.cases = Array.from({length: numCases}, (_, i) => ({
                    number: i + 1,
                    opened: false,
                    value: null
                }));
                console.log(`Applied number of cases: ${numCases}`);
            }

            // Apply case opening sequence
            if (gameMasterSettings.caseOpeningSequence && gameMasterSettings.caseOpeningSequence.length > 0) {
                // Store the custom sequence for use in rounds
                gameState.customOpeningSequence = [...gameMasterSettings.caseOpeningSequence];
                console.log('Applied custom case opening sequence:', gameState.customOpeningSequence);
            }

            // Zero-amount trap logic disabled: all case values are manual via Game Master
            // gameState.zeroAmountCases is preserved for UI but does not alter values
        }

        // Initialize the game
        // Flexible value parser: returns number when numeric-like, otherwise trimmed text
        function parseValueFlex(raw) {
            try {
                const s = String(raw ?? '').trim();
                if (s === '') return 0;
                const num = parseCurrencyInput(s);
                if (isFinite(num)) return Math.round(num * 100) / 100;
                return s;
            } catch (_) {
                return 0;
            }
        }
        function initializeGame() {
            // Load Game Master Settings first
            loadGameMasterSettings();
            console.log('Loaded gameMasterSettings:', gameMasterSettings);

            // Determine number of cases (default 25, bounded between 10 and 50)
            const numCases = gameMasterSettings?.numberOfCases
                ? Math.max(10, Math.min(50, gameMasterSettings.numberOfCases))
                : 25;
            console.log('Initializing with numCases:', numCases);

            // Apply settings that affect prize generation
            applyGameMasterSettings();

            // Use only custom override; default to all zeros until set by Game Master
            let values;
            let usingCustomOverride = true;
            const hasOverride = !!(Array.isArray(gameMasterSettings?.customValuesOverride) && gameMasterSettings.customValuesOverride.length > 0);

            // Helper: parse raw string to dollar number with cent precision
            const parseAmountToDollars = (raw) => {
                if (typeof raw !== 'string') {
                    const n = Number(raw);
                    if (!isFinite(n) || n < 0) return 0;
                    return Math.round(n * 100) / 100;
                }
                const sanitized = raw.replace(/[,\s]/g, '');
                const n = Number(sanitized);
                if (!isFinite(n) || n < 0) return 0;
                return Math.round(n * 100) / 100;
            };

            if (hasOverride) {
                // Build values directly from override, respecting numCases
                const override = gameMasterSettings.customValuesOverride.slice(0, numCases);
                values = override.map(v => parseValueFlex(v));
            } else {
                // Default all values to $0.00 until Game Master updates
                values = Array.from({ length: numCases }, () => 0);
            }

            // Remove AI scaling and zero-amount traps logic; values are fully manual

            // Ensure values count matches number of cases
            values = values.slice(0, numCases);
            // Ensure values array matches the desired number of cases
            if (values.length > numCases) {
                values = values.slice(0, numCases);
            }
            if (values.length < numCases) {
                const padValue = values.length > 0 ? values[values.length - 1] : 0.01;
                while (values.length < numCases) values.push(padValue);
            }

            // Do not shuffle: keep index mapping so Game Master inputs align with cases

            // Assign values to cases upfront
            gameState.cases = Array.from({ length: numCases }, (_, i) => ({
                number: i + 1,
                opened: false,
                value: values[i]
            }));

            gameState.values = [...values];
            gameState.remainingValues = [...values];

            // Case opening sequence (custom)
            if (gameMasterSettings?.caseOpeningSequence && gameMasterSettings.caseOpeningSequence.length > 0) {
                gameState.customOpeningSequence = [...gameMasterSettings.caseOpeningSequence];
            }

            // Reset round info
            gameState.currentRound = 1;
            gameState.casesOpened = 0;
            // If a custom opening sequence is provided, use (and sanitize) its first value; otherwise default to 6
            const initialDesired = (gameState.customOpeningSequence && gameState.customOpeningSequence.length > 0)
                ? sanitizeCasesToOpen(gameState.customOpeningSequence[0])
                : 6;
            // Don't allow opening more cases than exist (excluding the player's case)
            gameState.casesToOpen = Math.min(initialDesired, getUnopenedSelectableCasesCount());
            gameState.offerMadeThisRound = false;
            gameState.gameActive = false;

            // Update UI
            updateValuesGrid();
            updateCasesGrid();

            // Ensure decision buttons exist and start disabled/visible
            try {
                const slot = ensureDecisionButtonsSlot();
                hideDecisionButtons();
                if (slot) {
                    slot.style.display = 'block';
                    slot.style.visibility = 'visible';
                }
            } catch (e) {
                console.warn('Failed to initialize decision buttons slot:', e);
            }

            // Apply UI layout enhancements after initial render
            setupUILayoutEnhancements();
        }

        // Update the values grid (descending order, accurate duplicate handling)
        function updateValuesGrid() {
            const valuesGrid = document.getElementById('valuesGrid');
            valuesGrid.innerHTML = '';

            // Split values into numeric and text for predictable ordering
            const numericValues = gameState.values.filter(v => typeof v === 'number' && isFinite(v));
            const textValues = gameState.values.filter(v => !(typeof v === 'number' && isFinite(v)));

            const sortedNumeric = numericValues.slice().sort((a, b) => b - a);
            const sortedText = textValues.slice().map(v => String(v)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

            const displayValues = [...sortedNumeric, ...sortedText];

            // Build remaining counts map to handle duplicates precisely
            const keyOf = (v) => (typeof v === 'number' && isFinite(v)) ? Number(v.toFixed(2)).toString() : String(v);
            const remainingCounts = {};
            gameState.remainingValues.forEach(v => {
                const k = keyOf(v);
                remainingCounts[k] = (remainingCounts[k] || 0) + 1;
            });

            displayValues.forEach((value, index) => {
                const k = keyOf(value);
                const count = remainingCounts[k] || 0;

                const valueItem = document.createElement('div');
                valueItem.className = 'value-item';
                valueItem.textContent = formatCurrency(value);

                // Append inline icon indicators for value type and attachments
                const icons = document.createElement('span');
                icons.className = 'value-icons';
                const isNum = (typeof value === 'number' && isFinite(value));
                // Type icon: $ for numeric, ðŸ”¤ for text
                icons.textContent = isNum ? '$' : 'ðŸ”¤';

                // Attachment indicators: check any case that holds this value and has attachments
                try {
                    const key = (v) => (typeof v === 'number' && isFinite(v)) ? Number(v.toFixed(2)).toString() : String(v);
                    const targetKey = key(value);
                    const hasAttachmentForValue = gameState.cases.some(c => {
                        const ck = key(c.value);
                        if (ck !== targetKey) return false;
                        const conf = gameMasterSettings?.customCaseContent?.[c.number];
                        return !!(conf && (conf.image || conf.sound || conf.text || conf.video));
                    });
                    if (hasAttachmentForValue) {
                        // Use a compact camera/music/page/video combo indicator
                        const attachIcons = [];
                        // Aggregate present types across matching cases
                        const typesPresent = { img: false, snd: false, txt: false, vid: false };
                        gameState.cases.forEach(c => {
                            const ck = key(c.value);
                            if (ck !== targetKey) return;
                            const conf = gameMasterSettings?.customCaseContent?.[c.number];
                            if (!conf) return;
                            if (conf.image) typesPresent.img = true;
                            if (conf.sound) typesPresent.snd = true;
                            if (conf.text) typesPresent.txt = true;
                            if (conf.video) typesPresent.vid = true;
                        });
                        if (typesPresent.img) attachIcons.push('ðŸ“·');
                        if (typesPresent.snd) attachIcons.push('ðŸ”Š');
                        if (typesPresent.txt) attachIcons.push('ðŸ“');
                        if (typesPresent.vid) attachIcons.push('ðŸŽ¬');
                        if (attachIcons.length) {
                            icons.textContent += ' ' + attachIcons.join('');
                        }
                    }
                } catch (_) {}

                valueItem.appendChild(icons);
                valueItem.dataset.index = String(index);

                if (count > 0) {
                    remainingCounts[k] = count - 1;
                } else {
                    valueItem.classList.add('eliminated');
                }

                valuesGrid.appendChild(valueItem);
            });
        }

        // Update the cases grid
        function updateCasesGrid() {
            const casesGrid = document.getElementById('casesGrid');
            casesGrid.innerHTML = '';

            // Determine display order: respect Game Master-provided order if present
            let orderedCases = gameState.cases;
            try {
                const order = Array.isArray(gameMasterSettings?.caseOrder) ? gameMasterSettings.caseOrder.slice() : null;
                if (order && order.length === gameState.cases.length) {
                    const byNumber = {};
                    gameState.cases.forEach(c => { byNumber[c.number] = c; });
                    orderedCases = order.map(n => byNumber[n]).filter(Boolean);
                }
            } catch {}

            orderedCases.forEach(caseData => {
                const caseElement = document.createElement('div');
                caseElement.className = 'case';
                caseElement.dataset.caseNumber = caseData.number;

                if (caseData.opened) {
                    caseElement.classList.add('opened');
                    caseElement.textContent = formatCurrency(caseData.value);
                } else {
                    const num = document.createElement('span');
                    num.className = 'case-number';
                    num.textContent = caseData.number;
                    caseElement.appendChild(num);
                    if (gameState.playerCase === caseData.number) {
                        caseElement.classList.add('selected');
                    }
                }

                caseElement.onclick = () => selectCase(caseData.number);
                casesGrid.appendChild(caseElement);
            });
            // Click sound delegated to case grid
            (function(){
                const onceHandler = (ev) => {
                    if (ev.target && ev.target.closest('.case')) { try { playTone(554.37, 0.08, 'sine'); } catch(e){} }
                    casesGrid.removeEventListener('click', onceHandler);
                };
                casesGrid.addEventListener('click', onceHandler);
            })();
        }

        // Select a case
        function selectCase(caseNumber) {
            // Don't allow case selection if game is not active or if decision buttons are showing
            if (!gameState.gameActive) {
                // Player selecting their case
                gameState.playerCase = caseNumber;
                gameState.gameActive = true;
                document.getElementById('gameStatus').textContent = `Open ${gameState.casesToOpen} cases to receive first offer`;

                // Remove player's case from available cases
                const playerCaseIndex = gameState.cases.findIndex(c => c.number === caseNumber);
                if (playerCaseIndex !== -1) {
                    gameState.cases[playerCaseIndex].selected = true;
                }

                updateCasesGrid();
                // Show any configured attachments for the selected case
                maybeShowCaseAttachment(caseNumber);
                return;
            }

            // If decision controls are active (enabled), block case opening until decision is made
            const slot = document.getElementById('decisionButtonsSlot');
            const decisionButtons = slot ? slot.querySelector('.decision-buttons') : null;
            const decisionActive = !!(decisionButtons && decisionButtons.dataset && decisionButtons.dataset.active === 'true');
            if (decisionActive) {
                return;
            }

            // Opening cases during game - only allow if still need to open cases in current round
            const allowedThisRound = Math.min(
                sanitizeCasesToOpen(gameState.casesToOpen || 1),
                getUnopenedSelectableCasesCount()
            );
            if (gameState.casesOpened < allowedThisRound) {
                const caseData = gameState.cases.find(c => c.number === caseNumber);
                if (caseData && !caseData.opened && caseData.number !== gameState.playerCase) {
                    openCase(caseNumber);
                } else if (caseData && caseData.number === gameState.playerCase) {
                    document.getElementById('gameStatus').textContent = "You cannot open your own case!";
                } else if (caseData && caseData.opened) {
                    document.getElementById('gameStatus').textContent = "This case is already opened!";
                }
            } else {
                document.getElementById('gameStatus').textContent = 'Round complete or no cases available to open - Enter offer above and click SET OFFER';
            }
        }

        // Open a case
        function openCase(caseNumber) {
            const caseIndex = gameState.cases.findIndex(c => c.number === caseNumber);
            if (caseIndex === -1) return;

            gameState.cases[caseIndex].opened = true;
            const openedValue = gameState.cases[caseIndex].value;

            // Show any configured attachments for the opened case
            maybeShowCaseAttachment(caseNumber, openedValue);

            // Remove from remaining values
            const valueIndex = gameState.remainingValues.indexOf(openedValue);
            if (valueIndex !== -1) {
                gameState.remainingValues.splice(valueIndex, 1);
            }

            // Update last value display
            document.getElementById('lastValue').textContent = `Last Opened: ${formatCurrency(openedValue)}`;

            // Highlight the opened value
            highlightValue(openedValue);

            gameState.casesOpened++;

            // Check if we have entered final round (only 2 cases remaining: player + 1 other)
            if (getUnopenedSelectableCasesCount() === 1) {
                gameState.finalRound = true;
                gameState.originalPlayerCase = gameState.playerCase;
                console.log('Entered final round - 2 cases remaining');
            }

            // Check if round is complete
            if (gameState.casesOpened >= gameState.casesToOpen) {
                // Round complete - only show status, host will manually set offer
                document.getElementById('gameStatus').textContent = 'Round complete - Enter offer above and click SET OFFER';
            } else {
                updateGameStatus();
            }

            updateCasesGrid();
            updateValuesGrid();
        }

        // ===== Case Attachments (Image/Audio) from Game Master Settings =====
        function maybeShowCaseAttachment(caseNumber, amount) {
            try {
                const conf = gameMasterSettings?.customCaseContent?.[caseNumber];
                if (!conf || (!conf.image && !conf.sound && !conf.text && !conf.video)) return;
                openCaseAttachmentModal(conf, amount);
            } catch (e) {
                console.error('Error showing case attachment:', e);
            }
        }

        function openCaseAttachmentModal(conf, amount) {
            const modal = document.getElementById('caseAttachmentModal');
            const imgEl = document.getElementById('attachmentImage');
            const audioEl = document.getElementById('attachmentAudio');
            const amountEl = document.getElementById('attachmentAmount');
            const textEl = document.getElementById('attachmentText');
            const videoEl = document.getElementById('attachmentVideo');

            if (!modal || !imgEl || !audioEl) return;

            if (conf.image) {
                imgEl.src = conf.image;
                imgEl.style.display = 'block';
            } else {
                imgEl.style.display = 'none';
                imgEl.removeAttribute('src');
            }

            if (conf.sound) {
                audioEl.src = conf.sound;
                audioEl.style.display = 'block';
                // Attempt to autoplay
                audioEl.play().catch(() => {});
            } else {
                audioEl.style.display = 'none';
                audioEl.removeAttribute('src');
            }

            if (textEl) {
                if (conf.text) {
                    textEl.textContent = conf.text;
                    textEl.style.display = 'block';
                } else {
                    textEl.textContent = '';
                    textEl.style.display = 'none';
                }
            }

            if (videoEl) {
                if (conf.video) {
                    videoEl.src = conf.video;
                    videoEl.style.display = 'block';
                } else {
                    videoEl.style.display = 'none';
                    videoEl.removeAttribute('src');
                }
            }

            // Show the opened case amount if provided
            if (typeof amount === 'number' && isFinite(amount) && amountEl) {
                amountEl.textContent = `Opened Amount: ${formatCurrency(amount)}`;
                amountEl.style.display = 'block';
            } else if (amountEl) {
                amountEl.textContent = '';
                amountEl.style.display = 'none';
            }

            modal.style.display = 'flex';
        }

        function closeCaseAttachmentModal() {
            const modal = document.getElementById('caseAttachmentModal');
            const audioEl = document.getElementById('attachmentAudio');
            if (audioEl) {
                try { audioEl.pause(); } catch (_) {}
            }
            if (modal) modal.style.display = 'none';
        }

        // Highlight opened value temporarily
        function highlightValue(value) {
            const valueItems = document.querySelectorAll('.value-item');
            valueItems.forEach(item => {
                if (item.textContent === formatCurrency(value)) {
                    item.classList.add('highlight');
                    setTimeout(() => {
                        item.classList.remove('highlight');
                    }, 2000);
                }
            });
        }

        // Update game status
        function updateGameStatus() {
            const remaining = gameState.casesToOpen - gameState.casesOpened;
            if (remaining > 0) {
                document.getElementById('gameStatus').textContent = `${remaining} more cases to open for offer`;
            }
        }

        // Helper: sanitize cases-to-open value to ensure it's a positive integer
        function sanitizeCasesToOpen(value) {
            const n = Number(value);
            if (!Number.isFinite(n) || n <= 0) return 1;
            return Math.max(1, Math.floor(n));
        }

        // Helper: how many cases can be opened (excluding player's case and already opened cases)
        function getUnopenedSelectableCasesCount() {
            return gameState.cases.filter(c => !c.opened && c.number !== gameState.playerCase).length;
        }

        // Real-life Banker calculations - no automated suggestions needed

        // Make an offer (only manual offers allowed)
        function makeOffer() {
            console.log('makeOffer() called');
            const manualOfferInput = document.getElementById('manualOffer');

            // If an offer was already made this round, ensure decision buttons are visible
            if (gameState.offerMadeThisRound) {
                const slot = document.getElementById('decisionButtonsSlot');
                const existingButtons = slot ? slot.querySelector('.decision-buttons') : null;
                if (!existingButtons) {
                    console.log('Offer already made; decision buttons missing. Rendering now.');
                    showDecisionButtons();
                } else {
                    console.log('Offer already made and buttons visible. No action.');
                }
                return;
            }

            const raw = manualOfferInput ? manualOfferInput.value : '';
            const trimmed = String(raw).trim();

            // Only allow manual offers - text or number
            if (!trimmed) {
                document.getElementById('gameStatus').textContent = 'Please enter a manual offer first';
                return;
            }

            const parsed = parseCurrencyInput(trimmed);
            const offerAmount = isFinite(parsed) ? parsed : trimmed; // accept text when not numeric

            manualOfferInput.value = ''; // Clear input

            console.log('Setting offer for this round');
            gameState.offerMadeThisRound = true;

            document.getElementById('gameStatus').textContent = `Banker's Offer: ${formatCurrency(offerAmount)} â€” Make Your Decision below`;

            const offerData = {
                round: gameState.currentRound,
                offer: offerAmount,
                decision: null
            };

            gameState.offerHistory.push(offerData);

            console.log('Offer added to history:', offerData);
            console.log('Current history array:', gameState.offerHistory);

            updateHistory();

            showDecisionButtons();
        }

        // Set manual offer
        function setManualOffer() {
            const manualOfferInput = document.getElementById('manualOffer');
            const offer = parseFloat(manualOfferInput.value);
            // Always delegate to makeOffer for validation and button rendering
            makeOffer();
        }

        // Handle player's decision
        function handleDecision(accepted) {
            const lastOffer = gameState.offerHistory[gameState.offerHistory.length - 1];
            if (lastOffer) {
                lastOffer.decision = accepted ? 'ACCEPTED' : 'REJECTED';
            }

            if (accepted) {
                // Player accepted - end game immediately
                endGame('ACCEPTED');
            } else {
                // Player rejected the offer
                if (gameState.finalRound) {
                    // Final round - show KEEP/SWAP decision
                    showKeepSwapButtons();
                } else {
                    // Continue to next round
                    nextRound();
                }
            }

            updateHistory();
            // Always hide decision buttons after a decision
            hideDecisionButtons();
        }

        // Ensure decision slot and buttons exist (persistently rendered)
        function ensureDecisionButtonsSlot() {
            let slot = document.getElementById('decisionButtonsSlot');
            if (!slot) {
                const offerSection = document.querySelector('.offer-section');
                if (offerSection && offerSection.parentNode) {
                    slot = document.createElement('div');
                    slot.id = 'decisionButtonsSlot';
                    slot.className = 'decision-buttons-slot';
                    slot.style.display = 'block';
                    slot.style.padding = '20px 0 40px 0';
                    slot.style.marginTop = '12px';
                    slot.style.border = '1px solid #ffd700';
                    slot.style.borderRadius = '8px';
                    slot.style.background = 'rgba(255,215,0,0.08)';
                    offerSection.parentNode.insertBefore(slot, offerSection.nextSibling);
                } else {
                    const controller = document.querySelector('.controller-panel');
                    if (controller) {
                        slot = document.createElement('div');
                        slot.id = 'decisionButtonsSlot';
                        slot.className = 'decision-buttons-slot';
                        slot.style.display = 'block';
                        slot.style.padding = '20px 0 40px 0';
                        slot.style.marginTop = '12px';
                        slot.style.border = '1px solid #ffd700';
                        slot.style.borderRadius = '8px';
                        slot.style.background = 'rgba(255,215,0,0.08)';
                        controller.appendChild(slot);
                    }
                }
            }

            if (!slot) return null;

            // Build label and button container only if missing
            let label = slot.querySelector('.decision-label');
            if (!label) {
                label = document.createElement('div');
                label.className = 'decision-label';
                label.textContent = 'Make Your Decision:';
                label.style.textAlign = 'center';
                label.style.color = '#ffd700';
                label.style.fontWeight = 'bold';
                label.style.marginBottom = '10px';
                slot.appendChild(label);
            }

            let buttonContainer = slot.querySelector('.decision-buttons');
            if (!buttonContainer) {
                buttonContainer = document.createElement('div');
                buttonContainer.className = 'decision-buttons';
                buttonContainer.style.display = 'flex';
                buttonContainer.style.gap = '15px';
                buttonContainer.style.justifyContent = 'center';

                const dealButton = document.createElement('button');
                dealButton.textContent = 'SHILL';
                dealButton.className = 'control-btn';
                dealButton.style.background = 'linear-gradient(45deg, #4CAF50, #66BB6A)';
                dealButton.style.color = 'white';
                dealButton.style.padding = '12px 24px';
                dealButton.style.fontSize = '16px';
                dealButton.style.fontWeight = 'bold';
                dealButton.style.borderRadius = '8px';
                dealButton.style.border = 'none';
                dealButton.style.cursor = 'pointer';
                dealButton.style.transition = 'all 0.3s ease';
                dealButton.onmouseover = () => { if (!dealButton.disabled) dealButton.style.transform = 'translateY(-2px)'; };
                dealButton.onmouseout = () => dealButton.style.transform = 'translateY(0)';
                dealButton.onclick = () => { if (!dealButton.disabled) handleDecision(true); };

                const noDealButton = document.createElement('button');
                noDealButton.textContent = 'NO SHILL';
                noDealButton.className = 'control-btn';
                noDealButton.style.background = 'linear-gradient(45deg, #f44336, #ef5350)';
                noDealButton.style.color = 'white';
                noDealButton.style.padding = '12px 24px';
                noDealButton.style.fontSize = '16px';
                noDealButton.style.fontWeight = 'bold';
                noDealButton.style.borderRadius = '8px';
                noDealButton.style.border = 'none';
                noDealButton.style.cursor = 'pointer';
                noDealButton.style.transition = 'all 0.3s ease';
                noDealButton.onmouseover = () => { if (!noDealButton.disabled) noDealButton.style.transform = 'translateY(-2px)'; };
                noDealButton.onmouseout = () => noDealButton.style.transform = 'translateY(0)';
                noDealButton.onclick = () => { if (!noDealButton.disabled) handleDecision(false); };

                buttonContainer.appendChild(dealButton);
                buttonContainer.appendChild(noDealButton);
                slot.appendChild(buttonContainer);
            }

            return slot;
        }

        // Disable decision buttons but keep them visible
        function hideDecisionButtons() {
            const slot = ensureDecisionButtonsSlot();
            if (!slot) return;
            const buttonContainer = slot.querySelector('.decision-buttons');
            const buttons = buttonContainer ? buttonContainer.querySelectorAll('button') : [];
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.filter = 'grayscale(35%)';
                btn.style.cursor = 'not-allowed';
                btn.style.transform = 'translateY(0)';
            });
            if (buttonContainer) buttonContainer.dataset.active = 'false';
            slot.style.display = 'block';
            slot.style.visibility = 'visible';
        }

        // Move to next round
        function nextRound() {
            console.log(`nextRound() called - current round: ${gameState.currentRound}`);
            console.log('Remaining selectable cases:', getUnopenedSelectableCasesCount());
            // Hide any lingering decision buttons when advancing rounds
            hideDecisionButtons();
            gameState.currentRound++;
            gameState.offerMadeThisRound = false; // Reset offer flag for new round
            console.log(`Moved to round ${gameState.currentRound}`);

            // Use custom case opening sequence if available, otherwise use default
            if (gameState.customOpeningSequence && gameState.customOpeningSequence.length >= gameState.currentRound) {
                gameState.casesToOpen = gameState.customOpeningSequence[gameState.currentRound - 1];
                console.log(`Using custom sequence - Round ${gameState.currentRound}: ${gameState.casesToOpen} cases to open`);
            } else {
                // Fallback to default sequence
                switch(gameState.currentRound) {
                    case 2: gameState.casesToOpen = 5; break;
                    case 3: gameState.casesToOpen = 4; break;
                    case 4: gameState.casesToOpen = 3; break;
                    case 5: gameState.casesToOpen = 2; break;
                    case 6: gameState.casesToOpen = 1; break;
                    case 7: gameState.casesToOpen = 1; break;
                    case 8: gameState.casesToOpen = 1; break;
                    case 9: gameState.casesToOpen = 1; break;
                    case 10: gameState.casesToOpen = 1; break;
                    case 11: gameState.casesToOpen = 1; break;
                    case 12: gameState.casesToOpen = 1; break;
                    case 13: gameState.casesToOpen = 1; break;
                    case 14: gameState.casesToOpen = 1; break;
                    case 15: gameState.casesToOpen = 1; break;
                    case 16: gameState.casesToOpen = 1; break;
                    case 17: gameState.casesToOpen = 1; break;
                    case 18: gameState.casesToOpen = 1; break;
                    case 19: gameState.casesToOpen = 1; break;
                    case 20: gameState.casesToOpen = 1; break;
                    default: gameState.casesToOpen = 1;
                }
                console.log(`Using default sequence - Round ${gameState.currentRound}: raw ${gameState.casesToOpen} cases to open`);
            }

            // Cap casesToOpen by remaining selectable cases (and sanitize)
            const selectable = getUnopenedSelectableCasesCount();
            console.log(`Selectable cases count: ${selectable}`);
            const rawCasesToOpen = gameState.casesToOpen;
            gameState.casesToOpen = Math.max(1, Math.min(
                sanitizeCasesToOpen(gameState.casesToOpen || 1),
                selectable
            ));
            console.log(`Capped casesToOpen from ${rawCasesToOpen} to ${gameState.casesToOpen}`);
            if (gameState.casesToOpen > selectable) {
                console.warn(`Wanted to set casesToOpen to ${rawCasesToOpen} but capped to ${gameState.casesToOpen} due to selectable limit`);
            }
            gameState.casesOpened = 0;
            document.getElementById('gameStatus').textContent = `Round ${gameState.currentRound}: Open ${gameState.casesToOpen} cases`;
            console.log(`Set status to: Round ${gameState.currentRound}: Open ${gameState.casesToOpen} cases`);
        }

        // End the game
        function endGame(reason) {
            gameState.gameActive = false;

            if (reason === 'ACCEPTED') {
                const lastOffer = gameState.offerHistory[gameState.offerHistory.length - 1];
                const offerDisplay = lastOffer ? formatCurrency(lastOffer.offer) : '$0';
                document.getElementById('gameStatus').textContent = `SHILL! Player accepted ${offerDisplay}`;
            } else {
                // Reveal player's case
                const playerCaseData = gameState.cases.find(c => c.number === gameState.playerCase);
                const caseAmt = playerCaseData?.value ?? 0;
                document.getElementById('gameStatus').textContent = `NO SHILL! Player's case: ${formatCurrency(caseAmt)}`;
            }
        }

        // Update history display
        function updateHistory() {
            console.log('updateHistory() called');
            console.log('Current offerHistory:', gameState.offerHistory);

            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';

            if (gameState.offerHistory.length === 0) {
                console.log('No offers in history yet');
                return;
            }

            gameState.offerHistory.slice().reverse().forEach((offer, index) => {
                console.log('Processing offer for display:', offer);

                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';

                const decisionClass = offer.decision === 'ACCEPTED' ? 'accept' : 'reject';
                historyItem.innerHTML = `
                    <div>Round ${offer.round}: <span class="history-offer">${formatCurrency(offer.offer)}</span></div>
                    <div>Decision: <span class="history-decision ${decisionClass}">${offer.decision || 'PENDING'}</span></div>
                `;

                historyList.appendChild(historyItem);
            });

            console.log('History display updated with', gameState.offerHistory.length, 'offers');
        }

        // Format currency (robust against null/undefined)
        function formatCurrency(amount) {
            if (typeof amount === 'number' && isFinite(amount)) {
                if (amount < 1) {
                    return `$${amount.toFixed(2)}`;
                }
                return `$${amount.toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
            }
            const s = String(amount ?? '');
            return s === '' ? '$0' : s;
        }

        // Parse inputs like "$1,000" or "1,000" into a number
        function parseCurrencyInput(value) {
            if (value == null) return NaN;
            try {
                const cleaned = String(value).replace(/[^0-9.\-]/g, '');
                const num = parseFloat(cleaned);
                return isFinite(num) ? num : NaN;
            } catch (_) {
                return NaN;
            }
        }

        // Max prize input removed: use gameMasterSettings.maxPrizeAmount via applyGameMasterSettings()

        // Generate custom prize values from $0 to customMaxPrize
        function generateCustomPrizeValues(numCases) {
            if (!customMaxPrize || customMaxPrize <= 0) {
                return [...BASE_STANDARD_VALUES]; // Fallback to standard values
            }

            // Generate values from $0 to customMaxPrize using an exponential curve for spacing
            const values = [];
            const maxVal = customMaxPrize;
            const gamma = 3; // curvature (higher -> more small values)

            for (let i = 0; i < numCases; i++) {
                const ratio = i / (numCases - 1);
                const scaledVal = maxVal * Math.pow(ratio, gamma);
                const roundedVal = Math.max(0, Math.round(scaledVal * 100) / 100);
                values.push(roundedVal);
            }

            console.log(`Generated custom prizes from $0 to ${formatCurrency(maxVal)}:`, values);
            return values;
        }

        // Start new game
        function startNewGame() {
            gameState = {
                cases: [],
                values: [],
                remainingValues: [],
                playerCase: null,
                currentRound: 1,
                casesToOpen: 6,
                casesOpened: 0,
                gameActive: false,
                offerHistory: [],
                offerMadeThisRound: false,
                finalRound: false,
                originalPlayerCase: null
            };

            document.getElementById('lastValue').textContent = 'Last Opened: None';
            document.getElementById('gameStatus').textContent = 'Select your case to begin!';
            document.getElementById('historyList').innerHTML = '';

            initializeGame();
        }

        // Show KEEP/SWAP buttons for final round decision
        function showKeepSwapButtons() {
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'finalModal';
            modalOverlay.style.position = 'fixed';
            modalOverlay.style.top = '0';
            modalOverlay.style.left = '0';
            modalOverlay.style.width = '100%';
            modalOverlay.style.height = '100%';
            modalOverlay.style.background = 'rgba(0, 0, 0, 0.8)';
            modalOverlay.style.zIndex = '1000';
            modalOverlay.style.display = 'flex';
            modalOverlay.style.justifyContent = 'center';
            modalOverlay.style.alignItems = 'center';

            const modalContent = document.createElement('div');
            modalContent.style.background = '#1e3c72';
            modalContent.style.color = 'white';
            modalContent.style.padding = '30px';
            modalContent.style.borderRadius = '15px';
            modalContent.style.border = '3px solid #ffd700';
            modalContent.style.maxWidth = '500px';
            modalContent.style.textAlign = 'center';
            modalContent.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';

            const otherCase = gameState.cases.find(c => !c.opened && c.number !== gameState.playerCase)?.number || 'Unknown';
            modalContent.innerHTML = `
                <div style="font-size: 24px; font-weight: bold; color: #ffd700; margin-bottom: 20px;">FINAL ROUND DECISION</div>
                <div style="font-size: 16px; margin-bottom: 10px;">You have your case: <strong>${gameState.originalPlayerCase}</strong></div>
                <div style="font-size: 16px; margin-bottom: 30px;">The last remaining case is: <strong>${otherCase}</strong></div>
                <div style="font-size: 18px; color: #FFD700; margin-bottom: 20px;">Do you KEEP your case or SWAP to the last remaining case?</div>
                <div id="finalButtons" style="display: flex; gap: 20px; justify-content: center;"></div>
            `;

            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);

            // Get the button container
            const finalButtons = modalContent.querySelector('#finalButtons');

            // Create KEEP button
            const keepButton = document.createElement('button');
            keepButton.textContent = 'KEEP MY CASE';
            keepButton.className = 'modal-btn';
            keepButton.style.background = 'linear-gradient(45deg, #4CAF50, #66BB6A)';
            keepButton.style.color = 'white';
            keepButton.style.padding = '15px 25px';
            keepButton.style.fontSize = '16px';
            keepButton.style.fontWeight = 'bold';
            keepButton.style.border = 'none';
            keepButton.style.borderRadius = '8px';
            keepButton.style.cursor = 'pointer';
            keepButton.style.transition = 'all 0.3s ease';
            keepButton.style.minWidth = '150px';
            keepButton.onmouseover = () => keepButton.style.transform = 'translateY(-2px)';
            keepButton.onmouseout = () => keepButton.style.transform = 'translateY(0)';
            keepButton.onclick = () => handleFinalDecision('KEEP');

            // Create SWAP button
            const swapButton = document.createElement('button');
            swapButton.textContent = 'SWAP CASE';
            swapButton.className = 'modal-btn';
            swapButton.style.background = 'linear-gradient(45deg, #ff9800, #ffc107)';
            swapButton.style.color = 'black';
            swapButton.style.padding = '15px 25px';
            swapButton.style.fontSize = '16px';
            swapButton.style.fontWeight = 'bold';
            swapButton.style.border = 'none';
            swapButton.style.borderRadius = '8px';
            swapButton.style.cursor = 'pointer';
            swapButton.style.transition = 'all 0.3s ease';
            swapButton.style.minWidth = '150px';
            swapButton.onmouseover = () => swapButton.style.transform = 'translateY(-2px)';
            swapButton.onmouseout = () => swapButton.style.transform = 'translateY(0)';
            swapButton.onclick = () => handleFinalDecision('SWAP');

            finalButtons.appendChild(keepButton);
            finalButtons.appendChild(swapButton);
        }

        // Handle final KEEP/SWAP decision
        function handleFinalDecision(choice) {
            if (choice === 'SWAP') {
                // Find the last remaining case
                const finalCase = gameState.cases.find(c => !c.opened && c.number !== gameState.originalPlayerCase);
                if (finalCase) {
                    gameState.playerCase = finalCase.number;
                    console.log(`Player swapped to case ${finalCase.number}`);
                }
            } else {
                console.log(`Player kept original case ${gameState.originalPlayerCase}`);
            }

            // Reveal all remaining cases and show final result
            revealFinalCases(choice);
        }

        // Reveal final cases and show result
        function revealFinalCases(playerChoice) {
            // Reveal the player's chosen case
            const playerCaseData = gameState.cases.find(c => c.number === gameState.playerCase);
            const playerAmount = playerCaseData?.value ?? 0;

            // Find and reveal the other final case
            const otherFinalCase = gameState.cases.find(c => !c.opened && c.number !== gameState.playerCase);
            let otherAmount = 0;
            // Ensure player's chosen case is marked opened and attachments shown
            if (playerCaseData && !playerCaseData.opened) {
                playerCaseData.opened = true;
                try { maybeShowCaseAttachment(gameState.playerCase, playerAmount); } catch (_) {}
            }

            if (otherFinalCase) {
                otherFinalCase.opened = true; // Mark as opened
                otherAmount = otherFinalCase.value ?? 0;
                try { maybeShowCaseAttachment(otherFinalCase.number, otherAmount); } catch (_) {}
            }

            // Update the case display after revealing both
            updateCasesGrid();

            // Create result popup modal
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'resultModal';
            modalOverlay.style.position = 'fixed';
            modalOverlay.style.top = '0';
            modalOverlay.style.left = '0';
            modalOverlay.style.width = '100%';
            modalOverlay.style.height = '100%';
            modalOverlay.style.background = 'rgba(0, 0, 0, 0.9)';
            modalOverlay.style.zIndex = '1000';
            modalOverlay.style.display = 'flex';
            modalOverlay.style.justifyContent = 'center';
            modalOverlay.style.alignItems = 'center';

            const modalContent = document.createElement('div');
            modalContent.style.background = '#1e3c72';
            modalContent.style.color = 'white';
            modalContent.style.padding = '40px';
            modalContent.style.borderRadius = '20px';
            modalContent.style.border = '4px solid #ffd700';
            modalContent.style.maxWidth = '600px';
            modalContent.style.textAlign = 'center';
            modalContent.style.boxShadow = '0 0 30px rgba(0,0,0,0.8)';

            let resultText = `Player chose to ${playerChoice.toUpperCase()} and won ${formatCurrency(playerAmount)}!\n`;
            if (playerChoice === 'SWAP') {
                resultText += `They swapped from case ${gameState.originalPlayerCase} which had ${formatCurrency(otherAmount)}.`;
            } else {
                resultText += `They kept case ${gameState.playerCase}. The other final case had ${formatCurrency(otherAmount)}.`;
            }

            modalContent.innerHTML = `
                <div style="font-size: 32px; font-weight: bold; color: #ffd700; margin-bottom: 20px;">ðŸŽ‰ GAME RESULT ðŸŽ‰</div>
                <div style="font-size: 20px; line-height: 1.6; margin-bottom: 30px;">${resultText}</div>
                <button id="continueBtn" style="background: linear-gradient(45deg, #4CAF50, #66BB6A); color: white; padding: 15px 30px; font-size: 18px; font-weight: bold; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s ease;">NEW GAME</button>
            `;

            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);

            // Remove the final decision modal
            const modal = document.getElementById('finalModal');
            if (modal) modal.remove();

            // End the game
            gameState.gameActive = false;
            gameState.finalRound = false;

            // Update history with final details
            updateHistory();

            // Set up new game button
            document.getElementById('continueBtn').onclick = function() {
                const resultModal = document.getElementById('resultModal');
                if (resultModal) resultModal.remove();
                startNewGame();
            };

            console.log(`Game ended: Player ${playerChoice}d and won ${formatCurrency(playerAmount)}`);
        }

        // Show decision buttons after offer is made
        function showDecisionButtons() {
            console.log('showDecisionButtons() called');
            const slot = ensureDecisionButtonsSlot();
            if (!slot) return;
            const buttonContainer = slot.querySelector('.decision-buttons');
            const buttons = buttonContainer ? buttonContainer.querySelectorAll('button') : [];
            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.filter = 'none';
                btn.style.cursor = 'pointer';
            });
            if (buttonContainer) buttonContainer.dataset.active = 'true';
            slot.style.display = 'block';
            slot.style.visibility = 'visible';
            try { slot.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (_) {}
        }

        // Open Game Master Settings
        function openGameMasterSettings() {
            // Save current game state before opening settings
            const currentGameState = {
                gameState: gameState,
                timestamp: new Date().toISOString()
            };

            // Store current state in sessionStorage for potential recovery
            sessionStorage.setItem('shillOrNoShillGameState', JSON.stringify(currentGameState));

            // Open Game Master Settings in a new window
            const settingsWindow = window.open('game-master-settings.html', '_blank',
                'width=1400,height=900,scrollbars=yes,resizable=yes');

            if (settingsWindow) {
                // Pass current game state to settings window
                settingsWindow.onload = function() {
                    settingsWindow.postMessage({
                        type: 'currentGameState',
                        gameState: gameState
                    }, '*');
                };

                // Listener moved to global scope below to handle messages anytime
            } else {
                // Fallback if popup was blocked
                document.getElementById('gameStatus').textContent = 'Please allow popups to access Game Master Settings';
            }
        }

        // Handle incoming settings messages globally (from settings window or when launched from settings)
        function handleSettingsMessage(event) {
            const data = event.data || {};
            if (data.type === 'settingsUpdated' || data.type === 'gameSettings') {
                try {
                    // Merge and persist settings
                    gameMasterSettings = { ...(gameMasterSettings || {}), ...(data.settings || {}) };
                    localStorage.setItem('shillOrNoShillSettings', JSON.stringify(gameMasterSettings));
                    console.log('Applying incoming settings:', gameMasterSettings);

                    // Reinitialize the game with new settings for real-time update
                    initializeGame();

                    // Visual confirmation
                    const originalStatus = document.getElementById('gameStatus').textContent;
                    document.getElementById('gameStatus').textContent = 'Settings applied to game!';
                    document.getElementById('gameStatus').style.background = 'rgba(76, 175, 80, 0.3)';
                    setTimeout(() => {
                        document.getElementById('gameStatus').textContent = originalStatus;
                        document.getElementById('gameStatus').style.background = '';
                    }, 3000);
                } catch (e) {
                    console.error('Error applying incoming settings:', e);
                }
            }
        }

        // Register global listener once
        window.addEventListener('message', handleSettingsMessage);

        // Initialize the game when page loads
        window.onload = function() {
            initializeGame();
            setupUILayoutEnhancements();
            initTitleSparkles();
        };
    </script>
    <!-- Case Attachment Modal (Image/Audio) -->
    <div id="caseAttachmentModal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.65); display: none; align-items: center; justify-content: center; z-index: 1000;">
        <div style="background: #111; border: 2px solid rgba(255,215,0,0.7); border-radius: 12px; padding: 16px; width: min(720px, 92vw); color: #ffd700; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.6);">
            <button onclick="closeCaseAttachmentModal()" style="position: absolute; top: 8px; right: 8px; background: transparent; border: 1px solid rgba(255,215,0,0.7); color: #ffd700; border-radius: 6px; padding: 4px 8px; cursor: pointer;">âœ– Close</button>
            <div id="attachmentAmount" style="display:none; font-size: 1.4rem; font-weight: 700; color: #ffd700; text-align: center; margin: 8px 0 4px;">Opened Amount: $0.00</div>
            <div id="attachmentText" style="display:none; font-size: 1rem; color:#ffe67c; margin: 6px 0 8px; line-height:1.4; text-align:center;"></div>
            <div style="text-align: center; margin-bottom: 12px;">
                <img id="attachmentImage" alt="Case Attachment" style="max-width: 100%; max-height: 50vh; border-radius: 8px; display: none;" />
            </div>
            <video id="attachmentVideo" controls style="width: 100%; display: none; margin-top:8px; border-radius:8px;"></video>
            <audio id="attachmentAudio" controls style="width: 100%; display: none; margin-top:8px;"></audio>
        </div>
    </div>
    <script>
    (function(){
      // Load fonts.css dynamically to ensure Montserrat is available
      try { var link=document.createElement('link'); link.rel='stylesheet'; link.href='assets/css/fonts.css'; document.head.appendChild(link); } catch(e){}

      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      let audioCtx;
      function ensureCtx(){ if(!audioCtx) audioCtx = new AudioCtx(); }
      window.playTone = function(freq=440, dur=0.1, type='sine'){
        try {
          ensureCtx();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
          gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime+0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime+dur);
        } catch(e) {}
      };

      window.addEventListener('DOMContentLoaded', function(){
        try {
          var newGameBtn=document.getElementById('newGameBtn'); if(newGameBtn) newGameBtn.addEventListener('click', function(){ playTone(880,0.07,'triangle'); });
          var settingsBtn=document.getElementById('settingsBtn'); if(settingsBtn) settingsBtn.addEventListener('click', function(){ playTone(660,0.06,'square'); });
          var setOfferBtn=document.getElementById('setOfferBtn'); if(setOfferBtn) setOfferBtn.addEventListener('click', function(){ playTone(330,0.08,'sine'); });
          // Allow pressing Enter in offer input to set the offer
          var manualOfferInput=document.getElementById('manualOffer');
          if(manualOfferInput){
            manualOfferInput.addEventListener('keydown', function(e){
              if(e.key==='Enter'){
                try{ playTone(330,0.08,'sine'); }catch(_){}
                try{ makeOffer(); }catch(err){ console.error('Error calling makeOffer from Enter key:', err); }
              }
            });
          }

          // Auto-swap icons to AI versions if present
          var icons=document.querySelectorAll('img.icon');
          icons.forEach(function(img){ (async function(){
            var src=img.getAttribute('src');
            var candidates=[
              src.replace(/\.svg$/i,'.png'),
              src.replace(/assets\/images\/icons\//,'assets/images/icons/ai/'),
              src.replace(/\.svg$/i,'-ai.svg')
            ];
            for (var i=0;i<candidates.length;i++){
              try{ var res=await fetch(candidates[i], { cache: 'no-cache' }); if(res && res.ok){ img.src=candidates[i]; break; } }catch(e){}
            }
          })(); });
        } catch(e){}
      });
    })();
    </script>
</body>
</html>
