<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shill or No Shill - Host Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }

        /* Left Column - Monetary Values */
        .values-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #ffd700;
            overflow-y: auto;
        }

        .values-title {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .values-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .value-item {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #1e3c72;
            padding: 8px 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            border: 2px solid #ffd700;
        }

        .value-item.eliminated {
            background: linear-gradient(45deg, #666, #999);
            color: #ccc;
            text-decoration: line-through;
            opacity: 0.6;
        }

        .value-item.highlight {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        /* Center Column - Cases and Controls */
        .game-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #ffd700;
            display: flex;
            flex-direction: column;
        }

        .game-title {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.7));
        }

        .cases-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            flex: 1;
            margin-bottom: 20px;
        }

        .case {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #1e3c72;
            border: 2px solid #ffd700;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 60px;
        }

        .case:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
        }

        .case.opened {
            background: linear-gradient(45deg, #333, #555);
            color: #ffd700;
            animation: reveal 0.5s ease;
        }

        .case.selected {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: white;
            transform: scale(0.95);
        }

        @keyframes reveal {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .game-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .control-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .new-game-btn {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: white;
        }

        .new-game-btn:hover {
            background: linear-gradient(45deg, #45a049, #5cb860);
            transform: translateY(-2px);
        }

        .settings-btn {
            background: linear-gradient(45deg, #9C27B0, #E91E63);
            color: white;
            position: relative;
            overflow: hidden;
        }

        .settings-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
            opacity: 0;
        }

        .settings-btn:hover::before {
            animation: shine 0.6s ease-out;
            opacity: 1;
        }

        .settings-btn:hover {
            background: linear-gradient(45deg, #7B1FA2, #C2185B);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(156, 39, 176, 0.4);
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .game-status {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .status-text {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
        }

        /* Right Column - Controller and History */
        .controller-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #ffd700;
            display: flex;
            flex-direction: column;
        }

        .controller-title {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .offer-section {
            margin-bottom: 20px;
        }

        .max-prize-section {
            margin-bottom: 20px;
        }

        .max-prize-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ffd700;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.1);
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .set-max-prize-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #9C27B0, #E91E63);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .offer-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ffd700;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.1);
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .offer-input::placeholder {
            color: rgba(255, 215, 0, 0.7);
        }

        .set-offer-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .suggested-offer {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid #2196F3;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            color: #2196F3;
            margin-top: 10px;
        }

        .last-value {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .last-value-text {
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
        }

        .history-section {
            flex: 1;
        }

        .history-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
            text-align: center;
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 5px;
            padding: 8px;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .history-offer {
            color: #ffd700;
            font-weight: bold;
        }

        .history-decision {
            color: #4CAF50;
            font-weight: bold;
        }

        .history-decision.reject {
            color: #f44336;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                height: auto;
                padding: 5px;
            }

            .values-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .cases-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .game-controls {
                flex-direction: column;
                gap: 15px;
            }

            .control-btn {
                padding: 15px;
                font-size: 16px;
            }
        }

        @media (max-width: 768px) {
            .game-controls {
                flex-direction: column;
                gap: 10px;
            }

            .control-btn {
                padding: 12px;
                font-size: 14px;
            }

            .settings-btn span {
                font-size: 14px;
            }

            .cases-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .values-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
    <!-- Load Montserrat font and apply globally -->
    <link rel="stylesheet" href="assets/css/fonts.css">
</head>
<body>
    <div class="container">
        <!-- Left Column - Monetary Values -->
        <div class="values-panel">
            <div class="values-title">REMAINING VALUES</div>
            <div class="values-grid" id="valuesGrid">
                <!-- Values will be populated by JavaScript -->
            </div>
        </div>

        <!-- Center Column - Cases and Game Controls -->
        <div class="game-panel">
            <div class="game-title">SHILL OR NO SHILL</div>

            <div class="cases-grid" id="casesGrid">
                <!-- Cases will be populated by JavaScript -->
            </div>

            <div class="game-controls">
                <button class="control-btn new-game-btn" onclick="startNewGame()">NEW GAME</button>
                <button class="control-btn settings-btn" onclick="openGameMasterSettings()" title="Game Master Settings">
                    <span style="font-size: 16px;">⚙️</span> SETTINGS
                </button>
            </div>

            <div class="game-status">
                <div class="status-text" id="gameStatus">Select your case to begin!</div>
            </div>
        </div>

        <!-- Right Column - Controller and History -->
        <div class="controller-panel">
            <div class="controller-title">HOST CONTROLLER</div>

            <div class="max-prize-section">
                <input type="number" class="max-prize-input" id="maxPrizeAmount" placeholder="Enter Max Prize Amount ($)" min="1" step="100">
                <button class="set-max-prize-btn" onclick="setMaxPrize()">SET MAX PRIZE</button>
            </div>

            <div class="offer-section">
                <input type="number" class="offer-input" id="manualOffer" placeholder="Enter Banker's Offer ($)" min="0" step="100">
                <button class="set-offer-btn" onclick="setManualOffer()">SET OFFER</button>
                <!-- Manual Banker offers only - no suggestions needed -->
            </div>

            <div class="last-value">
                <div class="last-value-text" id="lastValue">Last Opened: None</div>
            </div>

            <div class="history-section">
                <div class="history-title">PROPOSITION HISTORY</div>
                <div class="history-list" id="historyList">
                    <!-- History items will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            cases: [],
            values: [],
            remainingValues: [],
            playerCase: null,
            currentRound: 1,
            casesToOpen: 6,
            casesOpened: 0,
            gameActive: false,
            offerHistory: [],
            offerMadeThisRound: false,
            finalRound: false, // Track final round state
            originalPlayerCase: null // Store original case for swap logic
        };

        // Custom max prize amount (can be set by game master)
        let customMaxPrize = null;

        // Standard Deal or No Deal values (base values before scaling)
        const BASE_STANDARD_VALUES = [
            0.01, 1, 5, 10, 25, 50, 75, 100, 200, 300, 400, 500, 750,
            1000, 5000, 10000, 25000, 50000, 75000, 100000, 200000, 300000, 400000, 500000, 750000, 1000000
        ];

        // Game Master Settings (loaded from localStorage)
        let gameMasterSettings = null;

        // Load Game Master Settings from localStorage
        function loadGameMasterSettings() {
            const savedSettings = localStorage.getItem('shillOrNoShillSettings');
            if (savedSettings) {
                try {
                    gameMasterSettings = JSON.parse(savedSettings);
                    console.log('Loaded Game Master Settings:', gameMasterSettings);
                    return true;
                } catch (e) {
                    console.error('Error loading Game Master Settings:', e);
                    gameMasterSettings = null;
                    return false;
                }
            }
            console.log('No Game Master Settings found, using defaults');
            gameMasterSettings = null;
            return false;
        }



        // Apply Game Master Settings to game
        function applyGameMasterSettings() {
            if (!gameMasterSettings) return;

            // Apply max prize amount (preferred over legacy prizeScaleMultiplier)
            if (gameMasterSettings.maxPrizeAmount && gameMasterSettings.maxPrizeAmount > 0) {
                customMaxPrize = gameMasterSettings.maxPrizeAmount;
                console.log(`Applied max prize amount from settings: ${customMaxPrize}`);
            }

            // Apply number of cases (if different from default 26)
            if (gameMasterSettings.numberOfCases && gameMasterSettings.numberOfCases !== 26) {
                const numCases = Math.max(10, Math.min(50, gameMasterSettings.numberOfCases));
                // Recreate cases array with new count
                gameState.cases = Array.from({length: numCases}, (_, i) => ({
                    number: i + 1,
                    opened: false,
                    value: null
                }));
                console.log(`Applied number of cases: ${numCases}`);
            }

            // Apply case opening sequence
            if (gameMasterSettings.caseOpeningSequence && gameMasterSettings.caseOpeningSequence.length > 0) {
                // Store the custom sequence for use in rounds
                gameState.customOpeningSequence = [...gameMasterSettings.caseOpeningSequence];
                console.log('Applied custom case opening sequence:', gameState.customOpeningSequence);
            }

            // Apply zero-amount cases (traps)
            if (gameMasterSettings.zeroAmountCases !== undefined) {
                gameState.zeroAmountCases = Math.max(0, Math.min(5, gameMasterSettings.zeroAmountCases));
                // Force the lowest values to be trap amounts (set to $0) regardless of scale
                if (Array.isArray(gameState.values) && gameState.values.length > 0) {
                    const sorted = [...gameState.values].sort((a, b) => a - b);
                    for (let i = 0; i < gameState.zeroAmountCases && i < sorted.length; i++) {
                        sorted[i] = 0;
                    }
                    gameState.values = sorted;
                }
                console.log(`Applied zero-amount cases (traps): ${gameState.zeroAmountCases}`);
            }
        }

        // Initialize the game
        function initializeGame() {
            // Load Game Master Settings first
            loadGameMasterSettings();
            console.log('Loaded gameMasterSettings:', gameMasterSettings);

            // Determine number of cases (default 26, bounded between 10 and 50)
            const numCases = gameMasterSettings?.numberOfCases
                ? Math.max(10, Math.min(50, gameMasterSettings.numberOfCases))
                : 26;
            console.log('Initializing with numCases:', numCases);

            // Apply settings that affect prize generation
            applyGameMasterSettings();

            // Use custom max prize values if set, otherwise start from standard values
            let values;
            if (customMaxPrize && customMaxPrize > 0) {
                values = generateCustomPrizeValues(numCases);
            } else {
                values = [...BASE_STANDARD_VALUES];
            }

            // Legacy: prizeScaleMultiplier support removed in favor of max prize input

            // Apply zero-amount cases (force lowest values to $0)
            if (gameMasterSettings?.zeroAmountCases !== undefined) {
                const zeroCount = Math.max(0, Math.min(5, gameMasterSettings.zeroAmountCases));
                const sorted = [...values].sort((a, b) => a - b);
                for (let i = 0; i < zeroCount && i < sorted.length; i++) {
                    sorted[i] = 0;
                }
                values = sorted;
            }

            // Ensure values count matches number of cases
            values = values.slice(0, numCases);
            if (values.length < numCases) {
                const padValue = values.length > 0 ? values[values.length - 1] : 0.01;
                while (values.length < numCases) values.push(padValue);
            }

            // Shuffle values for random case assignment
            values = values.sort(() => Math.random() - 0.5);

            // Assign values to cases upfront
            gameState.cases = Array.from({ length: numCases }, (_, i) => ({
                number: i + 1,
                opened: false,
                value: values[i]
            }));

            gameState.values = [...values];
            gameState.remainingValues = [...values];

            // Case opening sequence (custom)
            if (gameMasterSettings?.caseOpeningSequence && gameMasterSettings.caseOpeningSequence.length > 0) {
                gameState.customOpeningSequence = [...gameMasterSettings.caseOpeningSequence];
            }

            // Reset round info
            gameState.currentRound = 1;
            gameState.casesOpened = 0;
            // If a custom opening sequence is provided, use (and sanitize) its first value; otherwise default to 6
            const initialDesired = (gameState.customOpeningSequence && gameState.customOpeningSequence.length > 0)
                ? sanitizeCasesToOpen(gameState.customOpeningSequence[0])
                : 6;
            // Don't allow opening more cases than exist (excluding the player's case)
            gameState.casesToOpen = Math.min(initialDesired, getUnopenedSelectableCasesCount());
            gameState.offerMadeThisRound = false;
            gameState.gameActive = false;

            // Update UI
            updateValuesGrid();
            updateCasesGrid();
        }

        // Update the values grid
        function updateValuesGrid() {
            const valuesGrid = document.getElementById('valuesGrid');
            valuesGrid.innerHTML = '';

            gameState.values.forEach((value, index) => {
                const valueItem = document.createElement('div');
                valueItem.className = 'value-item';
                valueItem.textContent = formatCurrency(value);
                valueItem.dataset.index = index;

                if (!gameState.remainingValues.includes(value)) {
                    valueItem.classList.add('eliminated');
                }

                valuesGrid.appendChild(valueItem);
            });
        }

        // Update the cases grid
        function updateCasesGrid() {
            const casesGrid = document.getElementById('casesGrid');
            casesGrid.innerHTML = '';

            gameState.cases.forEach(caseData => {
                const caseElement = document.createElement('div');
                caseElement.className = 'case';
                caseElement.textContent = caseData.number;
                caseElement.dataset.caseNumber = caseData.number;

                if (caseData.opened) {
                    caseElement.classList.add('opened');
                    caseElement.textContent = formatCurrency(caseData.value);
                } else if (gameState.playerCase === caseData.number) {
                    caseElement.classList.add('selected');
                }

                caseElement.onclick = () => selectCase(caseData.number);
                casesGrid.appendChild(caseElement);
            });
        }

        // Select a case
        function selectCase(caseNumber) {
            // Don't allow case selection if game is not active or if decision buttons are showing
            if (!gameState.gameActive) {
                // Player selecting their case
                gameState.playerCase = caseNumber;
                gameState.gameActive = true;
                document.getElementById('gameStatus').textContent = `Open ${gameState.casesToOpen} cases to receive first offer`;

                // Remove player's case from available cases
                const playerCaseIndex = gameState.cases.findIndex(c => c.number === caseNumber);
                if (playerCaseIndex !== -1) {
                    gameState.cases[playerCaseIndex].selected = true;
                }

                updateCasesGrid();
                return;
            }

            // Check if decision buttons are currently showing (player needs to make a decision)
            const gameStatus = document.getElementById('gameStatus');
            const decisionButtons = gameStatus.querySelector('.decision-buttons');
            if (decisionButtons) {
                // Player needs to make a decision first - do nothing
                return;
            }

            // Opening cases during game - only allow if still need to open cases in current round
            const allowedThisRound = Math.min(
                sanitizeCasesToOpen(gameState.casesToOpen || 1),
                getUnopenedSelectableCasesCount()
            );
            if (gameState.casesOpened < allowedThisRound) {
                const caseData = gameState.cases.find(c => c.number === caseNumber);
                if (caseData && !caseData.opened && caseData.number !== gameState.playerCase) {
                    openCase(caseNumber);
                } else if (caseData && caseData.number === gameState.playerCase) {
                    document.getElementById('gameStatus').textContent = "You cannot open your own case!";
                } else if (caseData && caseData.opened) {
                    document.getElementById('gameStatus').textContent = "This case is already opened!";
                }
            } else {
                document.getElementById('gameStatus').textContent = 'Round complete or no cases available to open - Enter offer above and click SET OFFER';
            }
        }

        // Open a case
        function openCase(caseNumber) {
            const caseIndex = gameState.cases.findIndex(c => c.number === caseNumber);
            if (caseIndex === -1) return;

            gameState.cases[caseIndex].opened = true;
            const openedValue = gameState.cases[caseIndex].value;

            // Remove from remaining values
            const valueIndex = gameState.remainingValues.indexOf(openedValue);
            if (valueIndex !== -1) {
                gameState.remainingValues.splice(valueIndex, 1);
            }

            // Update last value display
            document.getElementById('lastValue').textContent = `Last Opened: ${formatCurrency(openedValue)}`;

            // Highlight the opened value
            highlightValue(openedValue);

            gameState.casesOpened++;

            // Check if we have entered final round (only 2 cases remaining: player + 1 other)
            if (getUnopenedSelectableCasesCount() === 1) {
                gameState.finalRound = true;
                gameState.originalPlayerCase = gameState.playerCase;
                console.log('Entered final round - 2 cases remaining');
            }

            // Check if round is complete
            if (gameState.casesOpened >= gameState.casesToOpen) {
                // Round complete - only show status, host will manually set offer
                document.getElementById('gameStatus').textContent = 'Round complete - Enter offer above and click SET OFFER';
            } else {
                updateGameStatus();
            }

            updateCasesGrid();
            updateValuesGrid();
        }

        // Highlight opened value temporarily
        function highlightValue(value) {
            const valueItems = document.querySelectorAll('.value-item');
            valueItems.forEach(item => {
                if (item.textContent === formatCurrency(value)) {
                    item.classList.add('highlight');
                    setTimeout(() => {
                        item.classList.remove('highlight');
                    }, 2000);
                }
            });
        }

        // Update game status
        function updateGameStatus() {
            const remaining = gameState.casesToOpen - gameState.casesOpened;
            if (remaining > 0) {
                document.getElementById('gameStatus').textContent = `${remaining} more cases to open for offer`;
            }
        }

        // Helper: sanitize cases-to-open value to ensure it's a positive integer
        function sanitizeCasesToOpen(value) {
            const n = Number(value);
            if (!Number.isFinite(n) || n <= 0) return 1;
            return Math.max(1, Math.floor(n));
        }

        // Helper: how many cases can be opened (excluding player's case and already opened cases)
        function getUnopenedSelectableCasesCount() {
            return gameState.cases.filter(c => !c.opened && c.number !== gameState.playerCase).length;
        }

        // Real-life Banker calculations - no automated suggestions needed

        // Make an offer (only manual offers allowed)
        function makeOffer() {
            console.log('makeOffer() called');
            const manualOfferInput = document.getElementById('manualOffer');
            const manualOffer = parseFloat(manualOfferInput.value);

            // Only allow manual offers - no automatic generation
            if (!manualOffer || manualOffer <= 0) {
                document.getElementById('gameStatus').textContent = 'Please enter a manual offer first';
                return;
            }

            const offerAmount = manualOffer;
            manualOfferInput.value = ''; // Clear input

            // Prevent duplicate offers in same round
            if (gameState.offerMadeThisRound) {
                console.log('Offer already made this round, exiting');
                return;
            }
            console.log('Setting offer for this round');
            gameState.offerMadeThisRound = true;

            // Show offer to player (in real implementation, this would be on a separate display)
            document.getElementById('gameStatus').textContent = `Banker's Offer: ${formatCurrency(offerAmount)}`;

            // Add to history
            const offerData = {
                round: gameState.currentRound,
                offer: offerAmount,
                decision: null
            };

            gameState.offerHistory.push(offerData);

            // Debug logging
            console.log('Offer added to history:', offerData);
            console.log('Current history array:', gameState.offerHistory);

            updateHistory();

            // Show decision buttons
            console.log('Calling showDecisionButtons()');
            showDecisionButtons();
        }

        // Set manual offer
        function setManualOffer() {
            const manualOfferInput = document.getElementById('manualOffer');
            const offer = parseFloat(manualOfferInput.value);

            if (offer > 0) {
                makeOffer();
            }
        }

        // Handle player's decision
        function handleDecision(accepted) {
            const lastOffer = gameState.offerHistory[gameState.offerHistory.length - 1];
            if (lastOffer) {
                lastOffer.decision = accepted ? 'ACCEPTED' : 'REJECTED';
            }

            if (accepted) {
                // Player accepted - end game immediately
                endGame('ACCEPTED');
            } else {
                // Player rejected the offer
                if (gameState.finalRound) {
                    // Final round - show KEEP/SWAP decision
                    showKeepSwapButtons();
                } else {
                    // Continue to next round
                    nextRound();
                }
            }

            updateHistory();

            // Remove existing decision buttons (only if not showing KEEP/SWAP)
            if (!accepted || !gameState.finalRound) {
                const gameStatus = document.getElementById('gameStatus');
                const existingContainer = gameStatus.querySelector('.decision-buttons');
                if (existingContainer) {
                    existingContainer.remove();
                }
            }
        }

        // Move to next round
        function nextRound() {
            console.log(`nextRound() called - current round: ${gameState.currentRound}`);
            console.log('Remaining selectable cases:', getUnopenedSelectableCasesCount());
            gameState.currentRound++;
            gameState.offerMadeThisRound = false; // Reset offer flag for new round
            console.log(`Moved to round ${gameState.currentRound}`);

            // Use custom case opening sequence if available, otherwise use default
            if (gameState.customOpeningSequence && gameState.customOpeningSequence.length >= gameState.currentRound) {
                gameState.casesToOpen = gameState.customOpeningSequence[gameState.currentRound - 1];
                console.log(`Using custom sequence - Round ${gameState.currentRound}: ${gameState.casesToOpen} cases to open`);
            } else {
                // Fallback to default sequence
                switch(gameState.currentRound) {
                    case 2: gameState.casesToOpen = 5; break;
                    case 3: gameState.casesToOpen = 4; break;
                    case 4: gameState.casesToOpen = 3; break;
                    case 5: gameState.casesToOpen = 2; break;
                    case 6: gameState.casesToOpen = 1; break;
                    case 7: gameState.casesToOpen = 1; break;
                    case 8: gameState.casesToOpen = 1; break;
                    case 9: gameState.casesToOpen = 1; break;
                    case 10: gameState.casesToOpen = 1; break;
                    case 11: gameState.casesToOpen = 1; break;
                    case 12: gameState.casesToOpen = 1; break;
                    case 13: gameState.casesToOpen = 1; break;
                    case 14: gameState.casesToOpen = 1; break;
                    case 15: gameState.casesToOpen = 1; break;
                    case 16: gameState.casesToOpen = 1; break;
                    case 17: gameState.casesToOpen = 1; break;
                    case 18: gameState.casesToOpen = 1; break;
                    case 19: gameState.casesToOpen = 1; break;
                    case 20: gameState.casesToOpen = 1; break;
                    default: gameState.casesToOpen = 1;
                }
                console.log(`Using default sequence - Round ${gameState.currentRound}: raw ${gameState.casesToOpen} cases to open`);
            }

            // Cap casesToOpen by remaining selectable cases (and sanitize)
            const selectable = getUnopenedSelectableCasesCount();
            console.log(`Selectable cases count: ${selectable}`);
            const rawCasesToOpen = gameState.casesToOpen;
            gameState.casesToOpen = Math.max(1, Math.min(
                sanitizeCasesToOpen(gameState.casesToOpen || 1),
                selectable
            ));
            console.log(`Capped casesToOpen from ${rawCasesToOpen} to ${gameState.casesToOpen}`);
            if (gameState.casesToOpen > selectable) {
                console.warn(`Wanted to set casesToOpen to ${rawCasesToOpen} but capped to ${gameState.casesToOpen} due to selectable limit`);
            }
            gameState.casesOpened = 0;
            document.getElementById('gameStatus').textContent = `Round ${gameState.currentRound}: Open ${gameState.casesToOpen} cases`;
            console.log(`Set status to: Round ${gameState.currentRound}: Open ${gameState.casesToOpen} cases`);
        }

        // End the game
        function endGame(reason) {
            gameState.gameActive = false;

            if (reason === 'ACCEPTED') {
                const lastOffer = gameState.offerHistory[gameState.offerHistory.length - 1];
                const offerAmt = lastOffer && typeof lastOffer.offer === 'number' ? lastOffer.offer : 0;
                document.getElementById('gameStatus').textContent = `SHILL! Player accepted ${formatCurrency(offerAmt)}`;
            } else {
                // Reveal player's case
                const playerCaseData = gameState.cases.find(c => c.number === gameState.playerCase);
                const caseAmt = playerCaseData?.value ?? 0;
                document.getElementById('gameStatus').textContent = `NO SHILL! Player's case: ${formatCurrency(caseAmt)}`;
            }
        }

        // Update history display
        function updateHistory() {
            console.log('updateHistory() called');
            console.log('Current offerHistory:', gameState.offerHistory);

            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';

            if (gameState.offerHistory.length === 0) {
                console.log('No offers in history yet');
                return;
            }

            gameState.offerHistory.slice().reverse().forEach((offer, index) => {
                console.log('Processing offer for display:', offer);

                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';

                const decisionClass = offer.decision === 'ACCEPTED' ? 'accept' : 'reject';
                historyItem.innerHTML = `
                    <div>Round ${offer.round}: <span class="history-offer">${formatCurrency(offer.offer)}</span></div>
                    <div>Decision: <span class="history-decision ${decisionClass}">${offer.decision || 'PENDING'}</span></div>
                `;

                historyList.appendChild(historyItem);
            });

            console.log('History display updated with', gameState.offerHistory.length, 'offers');
        }

        // Format currency (robust against null/undefined)
        function formatCurrency(amount) {
            if (typeof amount !== 'number' || !isFinite(amount)) {
                return '$0';
            }
            if (amount < 1) {
                return `$${amount.toFixed(2)}`;
            }
            return `$${amount.toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
        }

        // Set maximum prize amount
        function setMaxPrize() {
            const maxPrizeInput = document.getElementById('maxPrizeAmount');
            const maxPrize = parseFloat(maxPrizeInput.value);

            if (maxPrize && maxPrize > 0) {
                customMaxPrize = maxPrize;
                maxPrizeInput.value = '';
                document.getElementById('gameStatus').textContent = `Maximum prize set to ${formatCurrency(maxPrize)}. Start a new game to use it!`;
                console.log(`Custom max prize set to: ${customMaxPrize}`);
            }
        }

        // Generate custom prize values from $0 to customMaxPrize
        function generateCustomPrizeValues(numCases) {
            if (!customMaxPrize || customMaxPrize <= 0) {
                return [...BASE_STANDARD_VALUES]; // Fallback to standard values
            }

            // Generate values from $0 to customMaxPrize using an exponential curve for spacing
            const values = [];
            const maxVal = customMaxPrize;
            const gamma = 3; // curvature (higher -> more small values)

            for (let i = 0; i < numCases; i++) {
                const ratio = i / (numCases - 1);
                const scaledVal = maxVal * Math.pow(ratio, gamma);
                const roundedVal = Math.max(0, Math.round(scaledVal * 100) / 100);
                values.push(roundedVal);
            }

            console.log(`Generated custom prizes from $0 to ${formatCurrency(maxVal)}:`, values);
            return values;
        }

        // Start new game
        function startNewGame() {
            gameState = {
                cases: [],
                values: [],
                remainingValues: [],
                playerCase: null,
                currentRound: 1,
                casesToOpen: 6,
                casesOpened: 0,
                gameActive: false,
                offerHistory: [],
                offerMadeThisRound: false,
                finalRound: false,
                originalPlayerCase: null
            };

            document.getElementById('lastValue').textContent = 'Last Opened: None';
            document.getElementById('gameStatus').textContent = 'Select your case to begin!';
            document.getElementById('historyList').innerHTML = '';

            initializeGame();
        }

        // Show KEEP/SWAP buttons for final round decision
        function showKeepSwapButtons() {
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'finalModal';
            modalOverlay.style.position = 'fixed';
            modalOverlay.style.top = '0';
            modalOverlay.style.left = '0';
            modalOverlay.style.width = '100%';
            modalOverlay.style.height = '100%';
            modalOverlay.style.background = 'rgba(0, 0, 0, 0.8)';
            modalOverlay.style.zIndex = '1000';
            modalOverlay.style.display = 'flex';
            modalOverlay.style.justifyContent = 'center';
            modalOverlay.style.alignItems = 'center';

            const modalContent = document.createElement('div');
            modalContent.style.background = '#1e3c72';
            modalContent.style.color = 'white';
            modalContent.style.padding = '30px';
            modalContent.style.borderRadius = '15px';
            modalContent.style.border = '3px solid #ffd700';
            modalContent.style.maxWidth = '500px';
            modalContent.style.textAlign = 'center';
            modalContent.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';

            const otherCase = gameState.cases.find(c => !c.opened && c.number !== gameState.playerCase)?.number || 'Unknown';
            modalContent.innerHTML = `
                <div style="font-size: 24px; font-weight: bold; color: #ffd700; margin-bottom: 20px;">FINAL ROUND DECISION</div>
                <div style="font-size: 16px; margin-bottom: 10px;">You have your case: <strong>${gameState.originalPlayerCase}</strong></div>
                <div style="font-size: 16px; margin-bottom: 30px;">The last remaining case is: <strong>${otherCase}</strong></div>
                <div style="font-size: 18px; color: #FFD700; margin-bottom: 20px;">Do you KEEP your case or SWAP to the last remaining case?</div>
                <div id="finalButtons" style="display: flex; gap: 20px; justify-content: center;"></div>
            `;

            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);

            // Get the button container
            const finalButtons = modalContent.querySelector('#finalButtons');

            // Create KEEP button
            const keepButton = document.createElement('button');
            keepButton.textContent = 'KEEP MY CASE';
            keepButton.className = 'modal-btn';
            keepButton.style.background = 'linear-gradient(45deg, #4CAF50, #66BB6A)';
            keepButton.style.color = 'white';
            keepButton.style.padding = '15px 25px';
            keepButton.style.fontSize = '16px';
            keepButton.style.fontWeight = 'bold';
            keepButton.style.border = 'none';
            keepButton.style.borderRadius = '8px';
            keepButton.style.cursor = 'pointer';
            keepButton.style.transition = 'all 0.3s ease';
            keepButton.style.minWidth = '150px';
            keepButton.onmouseover = () => keepButton.style.transform = 'translateY(-2px)';
            keepButton.onmouseout = () => keepButton.style.transform = 'translateY(0)';
            keepButton.onclick = () => handleFinalDecision('KEEP');

            // Create SWAP button
            const swapButton = document.createElement('button');
            swapButton.textContent = 'SWAP CASE';
            swapButton.className = 'modal-btn';
            swapButton.style.background = 'linear-gradient(45deg, #ff9800, #ffc107)';
            swapButton.style.color = 'black';
            swapButton.style.padding = '15px 25px';
            swapButton.style.fontSize = '16px';
            swapButton.style.fontWeight = 'bold';
            swapButton.style.border = 'none';
            swapButton.style.borderRadius = '8px';
            swapButton.style.cursor = 'pointer';
            swapButton.style.transition = 'all 0.3s ease';
            swapButton.style.minWidth = '150px';
            swapButton.onmouseover = () => swapButton.style.transform = 'translateY(-2px)';
            swapButton.onmouseout = () => swapButton.style.transform = 'translateY(0)';
            swapButton.onclick = () => handleFinalDecision('SWAP');

            finalButtons.appendChild(keepButton);
            finalButtons.appendChild(swapButton);
        }

        // Handle final KEEP/SWAP decision
        function handleFinalDecision(choice) {
            if (choice === 'SWAP') {
                // Find the last remaining case
                const finalCase = gameState.cases.find(c => !c.opened && c.number !== gameState.originalPlayerCase);
                if (finalCase) {
                    gameState.playerCase = finalCase.number;
                    console.log(`Player swapped to case ${finalCase.number}`);
                }
            } else {
                console.log(`Player kept original case ${gameState.originalPlayerCase}`);
            }

            // Reveal all remaining cases and show final result
            revealFinalCases(choice);
        }

        // Reveal final cases and show result
        function revealFinalCases(playerChoice) {
            // Reveal the player's chosen case
            const playerCaseData = gameState.cases.find(c => c.number === gameState.playerCase);
            const playerAmount = playerCaseData?.value ?? 0;

            // Find and reveal the other final case
            const otherFinalCase = gameState.cases.find(c => !c.opened && c.number !== gameState.playerCase);
            let otherAmount = 0;
            if (otherFinalCase) {
                otherFinalCase.opened = true; // Mark as opened
                otherAmount = otherFinalCase.value ?? 0;

                // Update the case display
                updateCasesGrid();
            }

            // Create result popup modal
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'resultModal';
            modalOverlay.style.position = 'fixed';
            modalOverlay.style.top = '0';
            modalOverlay.style.left = '0';
            modalOverlay.style.width = '100%';
            modalOverlay.style.height = '100%';
            modalOverlay.style.background = 'rgba(0, 0, 0, 0.9)';
            modalOverlay.style.zIndex = '1000';
            modalOverlay.style.display = 'flex';
            modalOverlay.style.justifyContent = 'center';
            modalOverlay.style.alignItems = 'center';

            const modalContent = document.createElement('div');
            modalContent.style.background = '#1e3c72';
            modalContent.style.color = 'white';
            modalContent.style.padding = '40px';
            modalContent.style.borderRadius = '20px';
            modalContent.style.border = '4px solid #ffd700';
            modalContent.style.maxWidth = '600px';
            modalContent.style.textAlign = 'center';
            modalContent.style.boxShadow = '0 0 30px rgba(0,0,0,0.8)';

            let resultText = `Player chose to ${playerChoice.toUpperCase()} and won ${formatCurrency(playerAmount)}!\n`;
            if (playerChoice === 'SWAP') {
                resultText += `They swapped from case ${gameState.originalPlayerCase} which had ${formatCurrency(otherAmount)}.`;
            } else {
                resultText += `They kept case ${gameState.playerCase}. The other final case had ${formatCurrency(otherAmount)}.`;
            }

            modalContent.innerHTML = `
                <div style="font-size: 32px; font-weight: bold; color: #ffd700; margin-bottom: 20px;">🎉 GAME RESULT 🎉</div>
                <div style="font-size: 20px; line-height: 1.6; margin-bottom: 30px;">${resultText}</div>
                <button id="continueBtn" style="background: linear-gradient(45deg, #4CAF50, #66BB6A); color: white; padding: 15px 30px; font-size: 18px; font-weight: bold; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s ease;">NEW GAME</button>
            `;

            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);

            // Remove the final decision modal
            const modal = document.getElementById('finalModal');
            if (modal) modal.remove();

            // End the game
            gameState.gameActive = false;
            gameState.finalRound = false;

            // Update history with final details
            updateHistory();

            // Set up new game button
            document.getElementById('continueBtn').onclick = function() {
                const resultModal = document.getElementById('resultModal');
                if (resultModal) resultModal.remove();
                startNewGame();
            };

            console.log(`Game ended: Player ${playerChoice}d and won ${formatCurrency(playerAmount)}`);
        }

        // Show decision buttons after offer is made
        function showDecisionButtons() {
            console.log('showDecisionButtons() called');
            const gameStatus = document.getElementById('gameStatus');

            // Remove existing buttons first
            const existingContainer = gameStatus.querySelector('.decision-buttons');
            if (existingContainer) {
                existingContainer.remove();
            }

            // Create new button container
            console.log('Creating decision button container');
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'decision-buttons';
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '15px';
            buttonContainer.style.marginTop = '15px';
            buttonContainer.style.justifyContent = 'center';

            // Create DEAL button
            const dealButton = document.createElement('button');
            dealButton.textContent = 'SHILL';
            dealButton.className = 'control-btn';
            dealButton.style.background = 'linear-gradient(45deg, #4CAF50, #66BB6A)';
            dealButton.style.color = 'white';
            dealButton.style.padding = '12px 24px';
            dealButton.style.fontSize = '16px';
            dealButton.style.fontWeight = 'bold';
            dealButton.style.borderRadius = '8px';
            dealButton.style.border = 'none';
            dealButton.style.cursor = 'pointer';
            dealButton.style.transition = 'all 0.3s ease';
            dealButton.onmouseover = () => dealButton.style.transform = 'translateY(-2px)';
            dealButton.onmouseout = () => dealButton.style.transform = 'translateY(0)';
            dealButton.onclick = () => handleDecision(true);

            // Create NO DEAL button
            const noDealButton = document.createElement('button');
            noDealButton.textContent = 'NO SHILL';
            noDealButton.className = 'control-btn';
            noDealButton.style.background = 'linear-gradient(45deg, #f44336, #ef5350)';
            noDealButton.style.color = 'white';
            noDealButton.style.padding = '12px 24px';
            noDealButton.style.fontSize = '16px';
            noDealButton.style.fontWeight = 'bold';
            noDealButton.style.borderRadius = '8px';
            noDealButton.style.border = 'none';
            noDealButton.style.cursor = 'pointer';
            noDealButton.style.transition = 'all 0.3s ease';
            noDealButton.onmouseover = () => noDealButton.style.transform = 'translateY(-2px)';
            noDealButton.onmouseout = () => noDealButton.style.transform = 'translateY(0)';
            noDealButton.onclick = () => handleDecision(false);

            buttonContainer.appendChild(dealButton);
            buttonContainer.appendChild(noDealButton);
            gameStatus.appendChild(buttonContainer);
        }

        // Open Game Master Settings
        function openGameMasterSettings() {
            // Save current game state before opening settings
            const currentGameState = {
                gameState: gameState,
                timestamp: new Date().toISOString()
            };

            // Store current state in sessionStorage for potential recovery
            sessionStorage.setItem('shillOrNoShillGameState', JSON.stringify(currentGameState));

            // Open Game Master Settings in a new window
            const settingsWindow = window.open('game-master-settings.html', '_blank',
                'width=1400,height=900,scrollbars=yes,resizable=yes');

            if (settingsWindow) {
                // Pass current game state to settings window
                settingsWindow.onload = function() {
                    settingsWindow.postMessage({
                        type: 'currentGameState',
                        gameState: gameState
                    }, '*');
                };

                // Listener moved to global scope below to handle messages anytime
            } else {
                // Fallback if popup was blocked
                document.getElementById('gameStatus').textContent = 'Please allow popups to access Game Master Settings';
            }
        }

        // Handle incoming settings messages globally (from settings window or when launched from settings)
        function handleSettingsMessage(event) {
            const data = event.data || {};
            if (data.type === 'settingsUpdated' || data.type === 'gameSettings') {
                try {
                    // Merge and persist settings
                    gameMasterSettings = { ...(gameMasterSettings || {}), ...(data.settings || {}) };
                    localStorage.setItem('shillOrNoShillSettings', JSON.stringify(gameMasterSettings));
                    console.log('Applying incoming settings:', gameMasterSettings);

                    // Reinitialize the game with new settings for real-time update
                    initializeGame();

                    // Visual confirmation
                    const originalStatus = document.getElementById('gameStatus').textContent;
                    document.getElementById('gameStatus').textContent = 'Settings applied to game!';
                    document.getElementById('gameStatus').style.background = 'rgba(76, 175, 80, 0.3)';
                    setTimeout(() => {
                        document.getElementById('gameStatus').textContent = originalStatus;
                        document.getElementById('gameStatus').style.background = '';
                    }, 3000);
                } catch (e) {
                    console.error('Error applying incoming settings:', e);
                }
            }
        }

        // Register global listener once
        window.addEventListener('message', handleSettingsMessage);

        // Initialize the game when page loads
        window.onload = function() {
            initializeGame();
        };
    </script>
</body>
</html>
